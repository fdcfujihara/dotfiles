{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"combination": {
		"scope": "haskell",
		"prefix": "combination",
		"body": [
			"-- >>> combinations 2 \"abc\"",
			"-- [\"ab\",\"ac\",\"ba\",\"bc\",\"ca\",\"cb\"]",
			"combinations k ns = filter ((== 2) . length . nub) $ mapM (const ns) [1 .. k]",
		],
	},
	"define function": {
		"scope": "haskell",
		"prefix": "define function",
		"body": [
			"-- >>> $1",
			"$1 $2 = $3",
		],
	},
	"windows": {
		"scope": "haskell",
		"prefix": "windows",
		"body": [
			"-- >>>  map (\\n -> windows n \"abcd\") [2,3,4,5] ",
			"-- [[\"ab\",\"bc\",\"cd\"],[\"abc\",\"bcd\"],[\"abcd\"],[]]",
			"windows n xz@(_:xs) ",
			"  | length window < n = []",
			"  | otherwise = window : windows n xs",
			"  where",
			"    window = take n xz",
			"windows n _ = []",
		],
	},
	"getLines": {
		"scope": "haskell",
		"prefix": "getLines",
		"body": [
			"-- usage:",
			"--   lines <- getLines",
			"--   let leadingLines = takeWhile (not . null) lines",
			"getLines :: IO [String]",
			"getLines = lines <$> getContents",
		],
	},
}